#include <iostream>
#include <cstdio>
#include <functional>
using namespace std;
const int N = 1e5 + 10;
int main() {
    // 很奇葩的做法，奇葩到我不想回忆我是怎么做这道题的。
    // 此处：n、l、c如题意，k存储的是初始未改动情况下的h。
    //       s存储的是排序后每个c[i]第一次出现的位置（可用两个数代替）。
    int n, l, c[N], s[N] = {0}, k;
    scanf("%d%d", &n, &l);
    for ( int i = 1; i <= n; i ++ )
        scanf("%d", &c[i]);
    sort( c + 1, c + n + 1, greater<int>() ); // 排序，greater好用。
    for ( k = 1; k <= n; k ++ ) {
        if ( !s[ c[k] ] )
            s[ c[k] ] = k; // 见上方解释。
        if ( c[k] <= k ) // 如果找到h，就可以停了。
            break;
    }
    // 注意此时需要理解，我们的目光应该更多地放在序号指针上。
    // 停下的h代表，h左侧的数一定都大于其序号，而h所对应的数则刚好处在临界点上，h所代表的数应该是从左到右看来第一个小于或等于其序号的。
    // 此时无论我们如何对左侧的数进行+1操作，左侧的数都不可能符合要求。
    // 我们从h所指向的数入手，如果它比其序号小很多的话，那其右侧会更小，则此时无论怎么给右侧+1，也不可能成立。
    // 所以极限情况是h比其序号小1（注意h本身已经不可以比序号大了，所以无非两种情况：等于其序号或其序号减一、其它），否则都不可能成立。
    if ( c[k] < k - 1 )
        printf("%d\n", k - 1); // 那此时h应该是它左侧那个数的序号，因为它本身和不存在是一样的。它左侧已经满足了。
    else {
        // 此时，(c[k]+1)就是我们要达到的目标，也就是h对应的数加一。
        int t = s[ c[k] ], m = t + l - 1;  // 最多能引用l个，m是最多能引用到哪里。
        if ( m >= c[k] + 1 && c[ m <= n ? m : n ] == c[t] )  // 判断是否能引用够。注意m可能超出去，c里可能有0。
            printf("%d\n", c[k] + 1);
        else printf("%d\n", c[k]);
    }
    return 0;
}
